---
title: "LDHat MCMC convergence assessment"
date: "`r Sys.Date()`"
output: html_document
params:
  wdirpop: ""
  dataset: ""
  chromosome: ""
  bpen: ""
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages, include=FALSE}
require(rmarkdown)
require(vcfR)
require(adegenet)
require(poppr)
require(ggplot2)
require(ggpubr)
library(yaml)
library(reshape2)
# library(MCMCglmm)
library(coda)

# Set a global ggplot theme
ggplot2::theme_update(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(color="black", size=14, face="bold.italic",hjust = 0.5),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14),
        axis.text=element_text(size=14, colour="black"),
        legend.key = element_rect(fill = "white", linewidth = 1),
        legend.key.height = unit(2,"line"),
        legend.key.width = unit(5,"line"),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14))
```

```{r, echo = FALSE}
wdirpop = params$wdirpop
dataset = params$dataset
chromosome = params$chromosome
bpen = params$bpen

# TEST ONLY
wdirpop = "data/Arabidopsis_thaliana_1001genomes/K1.pop1"
dataset = "Arabidopsis_thaliana_1001genomes"
chromosome = "1"
bpen = 5
```


```{r, echo=FALSE}
cat("Dataset:", dataset, "\n")
cat("Chromosome:", chromosome, "\n")

yaml_config = read_yaml(paste0("data/", dataset, "/config.yaml"))
burnin = yaml_config$ldhat.burn
sampling = yaml_config$interval.samp
iterations = yaml_config$interval.iter

cat("Burnin:", burnin,"\n",
    "Sampling every", sampling,"iterations\n",
    "Total iterations of the chain:", iterations,"\n")
```

This document is a file automatically computed to assess LDhat MCMC chain convergence from multiple iterations of LDhat on a single dataset (different random seeds).



## Convergence of a single chain (the one used for estimates)

There is one MCMC estimate for each interval between SNPs, at each iteration (parallel chains for each interval).
Hence it is important to assess convergence within intervals by mixing posterior rates in intervals and between intervals by mixing the total map length (total map length should be stationary).


```{r mcmcChain, echo = FALSE}
cat("Loading MCMC sampling chain.\n")
mcmc.file = paste(wdirpop, "/ldhat/", dataset, ".", chromosome, ".bpen", bpen, ".rates.txt.gz", sep = "")
mcmc.chain = read.table(gzfile(mcmc.file), header = F, skip = 1)
# One line per position
# Each column is a MCMC iteration
# Do the mean of each column (minus first one) and check if mean posterior is stable across iterations
mean.posterior = data.frame(iteration = 1:(dim(mcmc.chain)[2] - 1),
                            posone = as.numeric(mcmc.chain[1,-1]),
                            pos1000 = as.numeric(mcmc.chain[1000,-1]),
                            posterior = apply(mcmc.chain[,-1], 2, median),
                            totalgenetic = apply(mcmc.chain[,-1], 2, sum))


# Median of all positions
p1 = ggplot(mean.posterior, aes(x = iteration, y = posterior)) +
  geom_line() +
  xlab("Sample") + ylab("Median posterior")
p1b = ggplot(mean.posterior, aes(x = posterior)) +
  geom_density() +
  xlab("Median posterior")
# One position
p2 = ggplot(mean.posterior, aes(x = iteration, y = posone)) +
  geom_line() +
  xlab("Sample") + ylab("Posterior position one")
p2b = ggplot(mean.posterior, aes(x = posone)) +
  geom_density() +
  xlab("Posterior position one")


# ggplot(mean.posterior, aes(x = iteration, y = pos1000)) +
#   geom_line()

# Total genetic distance ~ sample (iteration)
p3 = ggplot(mean.posterior, aes(x = iteration, y = totalgenetic)) +
  geom_line() +
  xlab("Sample") + ylab("Total genetic distance")
p3b = ggplot(mean.posterior, aes(x = totalgenetic)) +
  geom_density() +
  xlab("Total genetic distance")


p = ggarrange(p1, p1b, p2, p2b, p3, p3b, nrow = 3, ncol = 2, labels = "AUTO")
ggsave(paste(wdirpop, "/MCMC/", dataset, ".", chromosome, ".bpen", bpen, ".singleChain.jpeg", sep = ""),
       plot = p, device = jpeg(), width = 14, height = 12, dpi = 300)

rm(mcmc.chain)
```

```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.height = 8, fig.width = 14, fig.align="center", fig.cap = "Sampling chains and posterior distributions of the chians used to estimate Rho."}
plot(p)
```


## Summarise results with LDhat built-in functions


```{r sourceLDhat, echo=FALSE}
# Summary by LDhat built-in functions
# HEAVY Computations -> Server side to produce diagnostic figures
source("https://raw.githubusercontent.com/auton1/LDhat/master/coalescent.r")
```


```{r defineSummarise, echo = FALSE}
# Custom implementation of summarise.interval() to return figures output
burn.in = burnin

# rates.file = "data/test_ldhat_rates.txt"

summarise.interval.figure = function(rates.file="rates.txt", burn.in=30, locs.file=FALSE) {
  library(ggplot2)
  library(ggpubr)
  x = read.table(rates.file, skip=1, fill=T);
  
  maplength = data.frame(sample = (1:length(x[,1])))
  maplength$length = x[,1]
  
  chains = as.matrix(x[,-1]);
  
  low = as.integer(nrow(x)*burn.in/100);
  
  cat("\n\nSummarise output from MCMC estimation of recombination rates in INTERVAL (LDhat 2.1)\n\n");
  cat(paste("Number of SNPs = ", ncol(x), "\n", sep=""));
  cat(paste("Number of samples = ", nrow(x), "\n", sep=""));
  cat(paste("Burn-in period = ", low, " samples\n", sep=""));
  
  p1a = ggplot2::ggplot(data = maplength, aes(x = sample, y = length)) +
    geom_step() +
    xlab("Sample") + ylab("Total map length") +
    ggtitle("Mixing of total map length")
  
  data = expand.grid(X=c(1:nrow(x)), Y=c(1:(ncol(x)-1)))
  data$Z = unlist(c(log(x[,2:ncol(x)])))
  p1b = ggplot2::ggplot(data = data, aes(x = X, y = Y, fill = Z)) +
    geom_tile() +
    scale_color_viridis_c() +
    xlab("Sample") + ylab("log(rate) at SNP") +
    ggtitle("Mixing of rates")
  
  p1 = ggpubr::ggarrange(p1a, p1b, ncol = 2, widths = c(2, 3))
  
  # plot(x[,1], type="s", col=rgb(0,0,0.5), xlab="Sample", ylab="Total map length", 
  #      main="Mixing of total map length");
  # image(x=c(1:nrow(x)), y=c(1:(ncol(x)-1)), z=log(x[,2:ncol(x)]), xlab="Sample", 
  #       ylab="log(rate) at SNP", main="Mixing of rates");
  # 
  means<-apply(x[low:nrow(x),], 2, mean, na.rm=T);
  q.95<-apply(x[low:nrow(x),], 2, quantile, probs=c(0.025, 0.5, 0.975), na.rm=T);
  
  cat(paste("\nMean posterior total map length (4Ner) = ", signif(means[1], 4), "\n", sep=""));
  
  if (locs.file==FALSE) {pos<-c(1:ncol(x)); xlab<-"Position (SNP)";}
  else {pos<-as.vector(as.matrix(read.table(locs.file, as.is=T, skip=1))); xlab<-"Position"}
  
  df = data.frame(position = pos[1:(length(pos)-1)],
                  mean_rate = means[2:length(means)],
                  lower_rate = q.95[1,2:length(means)],
                  upper_rate = q.95[3,2:length(means)])
  
  p2 = ggplot2::ggplot(data = df, aes(x = position, y = mean_rate)) +
    geom_step(aes(y = lower_rate), colour = "Gray") +
    geom_step(aes(y = upper_rate), colour = "Gray") +
    geom_step(aes(y = mean_rate), colour = "Black") +
    xlab("Position") + ylab("Posterior mean rate") +
    ggtitle("Posterior mean rates")
  
  # plot(pos[1:(length(pos)-1)], y=means[2:length(means)], type="s", col=rgb(0,0,0.5), 	
  #      xlab=xlab, ylab="Posterior mean rate", main="Posterior mean rates");
  # lines(pos[1:(length(pos)-1)], y=q.95[1,2:length(means)], type="s", col=grey(0.75), lty="dotted");
  # lines(pos[1:(length(pos)-1)], y=q.95[3,2:length(means)], type="s", col=grey(0.75), lty="dotted");
  
  op<-cbind(means, t(q.95));
  colnames(op)<-c("Mean", "q2.5", "Median", "q97.5");
  
  return(list(p1, p2, op));
}

```


```{r summariseInterval, echo=FALSE}
# mcmc.file = "data/test_ldhat_rates.txt.gz"
mcmc.file = paste(wdirpop, "/ldhat/", dataset, ".", chromosome, ".bpen", bpen, ".rates.txt.gz", sep = "")
# locs.file = "data/Arabidopsis_thaliana_1001genomes/K1.pop1/ldhat/"
locs.file = paste(wdirpop, "/ldhat/", dataset, ".", chromosome, ".ldhat.locs", sep = "")
figures = summarise.interval.figure(rates.file = gzfile(mcmc.file), burn.in = burn.in, locs.file = locs.file)
```


```{r saveFig, echo=FALSE}
saveRDS(figures, file = paste(wdirpop, "/MCMC/", dataset, ".", chromosome, ".", bpen, ".MCMCsummary.Rds", sep = ""))
```


MCMC rates for each interval are mixed. Each line of panel B is the chain of a single interval. If there is convergence, all single interval chains should be stationary (no value/color fluctuation).


```{r plotFig1, message=FALSE, warning=FALSE, echo=FALSE, fig.height = 11, fig.width = 15, fig.align="center", fig.cap = "Mixing rates of the sampling chain."}
plot(figures[[1]])
ggsave(paste(wdirpop, "/MCMC/", dataset, ".", chromosome, ".bpen", bpen, ".mixingRates.jpeg", sep = ""),
       plot = figures[[1]], device = jpeg(), width = 14, height = 8, dpi = 300)
```



The mean posterior rate is the mean rate at each SNP position among all iterations of the sampling chain. If the sampling chain is stationary, the mean rate should be similar to the estimated recombination landscape.

```{r plotFig2, message=FALSE, warning=FALSE, echo=FALSE, fig.height = 11, fig.width = 15, fig.align="center", fig.cap = "Posterior rates of the sampling chain."}
plot(figures[[2]])
ggsave(paste(wdirpop, "/MCMC/", dataset, ".", chromosome, ".bpen", bpen, ".posteriorRates.jpeg", sep = ""),
       plot = figures[[2]], device = jpeg(), width = 14, height = 12, dpi = 300)
```


```{r plotLandscape, message=FALSE, warning=FALSE, echo=FALSE, fig.height = 11, fig.width = 15, fig.align="center", fig.cap = "Estimated recombination landscape."}
res.file = paste(wdirpop, "/ldhat/", dataset, ".", chromosome, ".bpen", bpen, ".res.txt.gz", sep = "")
res = read.table(gzfile(res.file), header = F, skip = 2)
colnames(res) = c("loci", "mean_rho", "median_rho", "lower", "upper")
res$loci = res$loci/10

landscape = ggplot(res, aes(x = loci, y = mean_rho)) +
  geom_line() +
  xlab("Genomic position (Mb)") + ylab("Mean recombination rate")

plot(landscape)
```



<!-- # Convergence over independent runs (10 runs in 'mcmc') -->

<!-- Strangely, LDhat does not require a random seed. I compared ten independent runs computed on the exact same data (population, individuals and markers), just launched ten times with LDhat. -->


<!-- ## Compare traceplots of individual chains -->

<!-- Cpmpare the ten traceplots of independent runs. -->


<!-- ```{r tenTraceplots, echo = FALSE} -->
<!-- cat("Plotting ten independent MCMC sampling chains.\n") -->

<!-- plots = list() -->

<!-- posterior = data.frame(run = character(), -->
<!--                        iter = numeric(), -->
<!--                        mean.posterior = numeric()) -->

<!-- for (i in 1:10) { -->
<!--   mcmc.file = paste(wdirpop, "/MCMC/", dataset, ".", chromosome, ".bpen", bpen, ".run.", i, ".rates.txt.gz", sep = "") -->
<!--   mcmc.chain = read.table(gzfile(mcmc.file), header = F, skip = 1) -->
<!--   mean.posterior = data.frame(iteration = 1:(dim(mcmc.chain)[2] - 1), -->
<!--                               posone = as.numeric(mcmc.chain[1,-1]), -->
<!--                               pos1000 = as.numeric(mcmc.chain[1000,-1]), -->
<!--                               posterior = apply(mcmc.chain[,-1], 2, mean), -->
<!--                               totalgenetic = apply(mcmc.chain[,-1], 2, sum)) -->

<!--   tmp = data.frame(run = i, -->
<!--                        iter = mean.posterior$iteration, -->
<!--                        mean.posterior = mean.posterior$posterior) -->
<!--   posterior = rbind(posterior, tmp) -->

<!--   p = ggplot(mean.posterior, aes(x = iteration, y = posterior)) + -->
<!--   geom_line() + -->
<!--   xlab("Sample") + ylab("Mean posterior") + -->
<!--   ggtitle(paste("Run #", i, sep = "")) -->
<!--   plots[[i]] = p -->
<!--   rm(mcmc.chain) -->
<!-- } -->

<!-- ``` -->

<!-- ```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.height = 8, fig.width = 14, fig.align="center", fig.cap = "Mean posterior rates of ten independent MCMC runs."} -->
<!-- for (i in 1:10) { -->
<!--   plot(plots[[i]]) -->
<!-- } -->

<!-- rm(plots) -->
<!-- ``` -->



<!-- ## Correlation between posterior rates -->


<!-- ```{r, echo=FALSE} -->
<!-- x = posterior$mean.posterior -->
<!-- groups = as.factor(posterior$run) -->

<!-- series = data.frame(run.1 = x[which(groups == "1")], -->
<!--                     run.2 = x[which(groups == "2")], -->
<!--                     run.3 = x[which(groups == "3")], -->
<!--                     run.4 = x[which(groups == "4")], -->
<!--                     run.5 = x[which(groups == "5")], -->
<!--                     run.6 = x[which(groups == "6")], -->
<!--                     run.7 = x[which(groups == "7")], -->
<!--                     run.8 = x[which(groups == "8")], -->
<!--                     run.9 = x[which(groups == "9")], -->
<!--                     run.10 = x[which(groups == "10")]) -->

<!-- # Function to add histograms -->
<!-- # panel.hist <- function(x, ...) { -->
<!-- #     usr <- par("usr") -->
<!-- #     on.exit(par(usr)) -->
<!-- #     par(usr = c(usr[1:2], 0, 1.5)) -->
<!-- #     his <- hist(x, plot = FALSE) -->
<!-- #     breaks <- his$breaks -->
<!-- #     nB <- length(breaks) -->
<!-- #     y <- his$counts -->
<!-- #     y <- y/max(y) -->
<!-- #     rect(breaks[-nB], 0, breaks[-1], y, col = rgb(0, 1, 1, alpha = 0.5), ...) -->
<!-- #     # lines(density(x), col = 2, lwd = 2) # Uncomment to add density lines -->
<!-- # } -->

<!-- # See sources in https://epurdom.github.io/Stat131A/lectures/2018SpringLectures/04MultiVisual_forClassCode.html -->
<!-- panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...) -->
<!-- { -->
<!--     #from help of pairs -->
<!--     usr <- par("usr"); on.exit(par(usr)) -->
<!--     par(usr = c(0, 1, 0, 1)) -->
<!--     r <- abs(cor(x, y,use="pairwise.complete.obs")) -->
<!--     txt <- format(c(r, 0.123456789), digits = digits)[1] -->
<!--     txt <- paste0(prefix, txt) -->
<!--     if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt) -->
<!--     text(0.5, 0.5, txt, cex = cex.cor * r) -->
<!-- } -->

<!-- panel.hist <- function(x, ...) -->
<!-- { -->
<!--     #from help of pairs -->
<!--     usr <- par("usr"); on.exit(par(usr)) -->
<!--     par(usr = c(usr[1:2], 0, 1.5) ) -->
<!--     h <- hist(x, plot = FALSE) -->
<!--     breaks <- h$breaks; nB <- length(breaks) -->
<!--     y <- h$counts; y <- y/max(y) -->
<!--     rect(breaks[-nB], 0, breaks[-1], y) -->
<!-- } -->

<!-- ``` -->


<!-- ```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.height = 8, fig.width = 14, fig.align="center", fig.cap = "Correlations between mean posterior rates of ten independent runs."} -->
<!-- # Creating the scatter plot matrix -->
<!-- pairs(series, -->
<!--       upper.panel = panel.cor,         # Disabling the upper panel -->
<!--       diag.panel = panel.hist)    # Adding the histograms -->
<!-- ``` -->



<!-- ## Subset MCMC chains dataset -->

<!-- MCMC chains are data-intensive (in practice there is one chain per SNP interval). To do it in a reasonable time, I reduced the data to a subset of 10,000 random intervals for each run (shape of the matrix 2,000 sampling x 10,000 intervals for each run). -->



<!-- ```{r subsetChains, echo=FALSE} -->
<!-- runs = list() -->

<!-- for (i in 1:10) { -->
<!--   mcmc.file = paste(wdirpop, "/MCMC/", dataset, ".", chromosome, ".bpen", bpen, ".run.", i, ".rates.txt.gz", sep = "") -->
<!--   mcmc.chain = read.table(gzfile(mcmc.file), header = F, skip = 1) -->
<!--   mcmc.chain = mcmc.chain[,10000] -->
<!--   runs[[i]] = as.mcmc(mcmc.chain) -->
<!--   rm(mcmc.chain) -->
<!-- } -->
<!-- ``` -->



<!-- ## Geweke diagnostic of MCMC Chain stability -->

<!-- ```{r, echo=FALSE} -->
<!-- #========================================================================# -->
<!-- # Geweke Diagnostic of MC Chain Stability -->
<!-- #------------------------------------------------------------------------# -->
<!-- # if the whole chain is stationary, the means of the values early and late in the sequence should be similar -->
<!-- # convergence diagnostic 'Z' is the difference between the 2 means divided by the asymptotic standard error of their difference -->
<!-- # values of 'Z' near the extreme tails of the N(0,1) indicates lack of convergence -->
<!-- # can also estimate p-value of 'Z' from the normal distribution -->
<!-- # yields the probability that the divided chain means are different -->
<!-- ``` -->


<!-- ```{r, echo=TRUE} -->
<!-- ?geweke.diag -->
<!-- ?geweke.plot -->
<!-- ``` -->


<!-- If the whole chain is stationary, the means of the values early and late in the sequence should be similar. The convergence diagnostic 'Z' is the difference between the two means divided by the asymptotic standard error of their difference. -->
<!-- Values of 'Z' near the extreme tails of the N(0,1) indicates lack of convergence. We can also estimate p-value of 'Z' from the normal distribution which yield the probability that the divided chain means are different. -->

<!-- Distribution of Geweke diagnostic values 'Z' computed for convergence in each interval single chain (10,000 values). -->
<!-- (A) Density -->
<!-- (B) Map of 'Z' along 10,000 SNPs -->


<!-- ```{r, echo=FALSE} -->
<!-- # runs[[i]] -->
<!-- geweke = geweke.diag(runs[[i]]) -->
<!-- # geweke.plot(runs[[i]]) -->
<!-- ``` -->


<!-- ```{r, echo=FALSE} -->
<!-- df = data.frame(position = 1:length(geweke$z), -->
<!--                 Z = geweke$z) -->

<!-- ggplot2::ggplot(data = df, aes(x = Z)) + -->
<!--   geom_density() + -->
<!--   geom_vline(xintercept = 1, color = "Red") + -->
<!--   geom_vline(xintercept = -1, color = "Red") + -->
<!--   xlab("Geweke's Z") -->
<!-- ``` -->


<!-- ```{r, echo=FALSE} -->
<!-- ggplot2::ggplot(data = df, aes(x = position, y = Z)) + -->
<!--   geom_point() + -->
<!--   geom_hline(yintercept = 1, color = "Red") + -->
<!--   geom_hline(yintercept = -1, color = "Red") + -->
<!--   xlab("Position") + ylab("Geweke's Z") -->
<!-- ``` -->


<!-- <!-- ## Heidelberger and Welch's Convergence Diagnostic --> -->

<!-- <!-- ```{r, echo=FALSE} --> -->
<!-- <!-- #========================================================================# --> -->
<!-- <!-- # Heidelberger and Welch's Convergence Diagnostic --> -->
<!-- <!-- #------------------------------------------------------------------------# --> -->
<!-- <!-- # probability of rejecting hypothesis that Markov Chain is a stable/stationary distribution --> -->
<!-- <!-- # if Halfwidth test fails, chain should be extended --> -->
<!-- <!-- # ?heidel.diag --> -->
<!-- <!-- ``` --> -->


<!-- ## Gelman diagnostic for testing convergence among chains -->


<!-- ```{r, echo=FALSE} -->
<!-- #========================================================================# -->
<!-- # Gelman diagnostic: 'potential scale reduction factor' -->
<!-- #------------------------------------------------------------------------# -->
<!-- # ?gelman.diag -->
<!-- #------------------------------------------------------------------------# -->
<!-- # Alphas -->
<!-- #------------------------------------------------------------------------# -->
<!-- # testing convergence among chains -->
<!-- #!# scaling factor should be less than 1.2 -->
<!-- # values substantially greater than 1 indicate lack of convergence -->
<!-- ``` -->


<!-- ```{r, echo=TRUE} -->
<!-- ?gelman.diag -->
<!-- ``` -->


<!-- The Gelman diagnostic is testing for convergence among independent chains. The scaling factor computed here should less than 1.2. Values substantially greater than one indicate a lack of convergennce. -->


<!-- Distribution of the Gelman scaling factor computed for each interval single chain (10,000 values). -->
<!-- (A) Density -->
<!-- (B) Map of 'scaling factor' along 10,000 SNPs -->

<!-- ```{r, echo=FALSE} -->
<!-- gelman.res = gelman.diag(runs, transform = FALSE, -->
<!--                          multivariate = FALSE) -->
<!-- ``` -->

<!-- ```{r, echo=FALSE} -->
<!-- gelman = data.frame(position = 1:length(gelman.res$psrf), -->
<!--                        psrf = gelman.res$psrf) -->
<!-- ggplot(data = gelman, aes(x = psrf.Point.est.)) +  -->
<!--   geom_density() + -->
<!--   xlab("Scale Reduction Factor") -->
<!-- ``` -->



<!-- ```{r, echo=FALSE} -->
<!-- ggplot2::ggplot(data = gelman, aes(x = position, y = psrf.Point.est.)) + -->
<!--   geom_point() + -->
<!--   xlab("Position") + ylab("Scale Reduction Factor") -->
<!-- ``` -->
